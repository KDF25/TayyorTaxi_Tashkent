import asyncio
import datetime

from click_api.models.insert_order import InsertCreatedOrder
from click_api.models.update_prepare import PrepareUpdate
from datetime_now import dt_now
import asyncpg
import config
from database.data import spots
import json



class Database:
    def __init__(self, loop: asyncio.AbstractEventLoop):
        self.pool: asyncio.pool.Pool = loop.run_until_complete(
            asyncpg.create_pool(
                database="Tashkent_taxi",
                user=config.PGUSER,
                password=config.PASSWORD,
                host=config.ip,
            )
        )

    async def sql_start(self):
        if self.pool:
            print('Data base connected ok!')
            await self._create_table_sub_spots()
            await self._create_table_all_users()
            await self._create_table_drivers()
            await self._create_table_orders_driver()
            await self._create_table_orders_client()
            await self._create_table_orders_accepted()
            await self._create_table_quiz()
            await self._create_table_relationship()
            await self._create_wallet_pay()
            await self._create_analise_client()
            await self._create_analise_driver()
            await self.create_table_transactions()
            await self.create_table_click_tran()
            # await self.add_relations(relation=relation)
            # await self.add_spots(spots=spots)

    async def _create_table_sub_spots(self):
        sql = """CREATE TABLE IF NOT EXISTS sub_spots(
                sub_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
                town_rus VARCHAR(255) NOT NULL,
                district_rus VARCHAR(255),
                spot_rus VARCHAR(255) NOT NULL,
                sub_spot_rus VARCHAR(255) NOT NULL, 
                town_uzb VARCHAR(255) NOT NULL,
                district_uzb VARCHAR(255),
                spot_uzb VARCHAR(255) NOT NULL,
                sub_spot_uzb VARCHAR(255) NOT NULL, 
                town_ozb VARCHAR(255) NOT NULL,
                district_ozb VARCHAR(255),
                spot_ozb VARCHAR(255) NOT NULL,
                sub_spot_ozb VARCHAR(255) NOT NULL)"""
        await self.pool.execute(sql)

    async def _create_table_relationship(self):
        sql = """   CREATE TABLE IF NOT EXISTS relationship(
                    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    data JSONB NOT NULL)"""
        await self.pool.execute(sql)

    async def _create_table_all_users(self):
        sql = """CREATE TABLE IF NOT EXISTS all_users(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL, 
                name VARCHAR(255) NOT NULL, 
                username VARCHAR(255),
                phone VARCHAR(255),
                language VARCHAR(255),
                status BOOL,
                deeplink VARCHAR(255),
                datetime_registration timestamp NOT NULL
                )"""
        await self.pool.execute(sql)

    async def _create_table_drivers(self):
        sql = """CREATE TABLE IF NOT EXISTS drivers(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                name VARCHAR(255) NOT NULL,
                username VARCHAR(255),        
                car BIGINT NOT NULL,
                color BIGINT NOT NULL,
                number VARCHAR(255) NOT NULL,
                phone BIGINT NOT NULL,   
                driver_rate NUMERIC(2,1) NOT NULL,
                datetime_registration timestamp NOT NULL,
                wallet_main BIGINT NOT NULL,
                wallet_bonus BIGINT NOT NULL,
                wallet_holiday BIGINT NOT NULL
                )"""
        await self.pool.execute(sql)

    async def _create_table_orders_driver(self):
        sql = """CREATE TABLE IF NOT EXISTS orders_driver(      
                order_driver_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,

                from_town BIGINT NOT NULL,
                location JSONB NOT NULL,
                to_town BIGINT NOT NULL,
                to_district BIGINT, 
                to_spot BIGINT NOT NULL,
                to_subspot BIGINT NOT NULL,

                datetime_trip timestamp NOT NULL,

                places BIGINT NOT NULL,
                price BIGINT NOT NULL,             

                datetime_open timestamp NOT NULL,
                datetime_close timestamp,
                cancel BOOL
                )"""
        await self.pool.execute(sql)

    async def _create_table_orders_client(self):
        sql = """CREATE TABLE IF NOT EXISTS orders_client(      
                order_client_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                order_driver_id BIGINT NOT NULL,
                client_id BIGINT NOT NULL,
                driver_id BIGINT NOT NULL,
                phone BIGINT NOT NULL,
                
                from_town BIGINT NOT NULL,
                location JSONB NOT NULL,
                to_district BIGINT,
                to_town BIGINT NOT NULL,
                to_spot BIGINT NOT NULL,
                to_subspot BIGINT NOT NULL,
                
                datetime_trip timestamp NOT NULL,
                
                places BIGINT NOT NULL, 
                price BIGINT NOT NULL, 
                cost BIGINT NOT NULL,     
                    
                datetime_open timestamp NOT NULL,
                order_accept BOOL 
                )"""
        await self.pool.execute(sql)

    async def _create_table_orders_accepted(self):
        sql = """CREATE TABLE IF NOT EXISTS orders_accepted(
                order_accept_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                order_client_id BIGINT NOT NULL,
                order_driver_id BIGINT NOT NULL,
                client_id BIGINT NOT NULL,
                driver_id BIGINT NOT NULL,
                phone_client BIGINT NOT NULL,
                phone_driver BIGINT NOT NULL,

                from_town BIGINT NOT NULL,
                location JSONB NOT NULL,
                to_district BIGINT,
                to_town BIGINT NOT NULL,
                to_spot BIGINT NOT NULL,
                to_subspot BIGINT NOT NULL,

                datetime_trip timestamp NOT NULL,
                
                places BIGINT NOT NULL,
                price BIGINT NOT NULL,  
                cost BIGINT NOT NULL,
                driver_rate BIGINT,

                datetime_accepted timestamp NOT NULL,
                datetime_cancel timestamp,
                cancel_driver BOOL,
                cancel_client BOOL
                )"""
        #  cancel_driver BOOL,      отмена заказа водителем после принятия заказа
        #  cancel_client BOOL,      отмена заказа клиентом после принятия заказа
        await self.pool.execute(sql)

    async def _create_wallet_pay(self):
        sql = """CREATE TABLE IF NOT EXISTS wallet_pay(
                pay_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                cash BIGINT NOT NULL,
                type_of_payment VARCHAR(255) NOT NULL,             
                datetime_payment timestamp NOT NULL,
                status BOOL NOT NULL
                )"""
        await self.pool.execute(sql)

    async def _create_table_quiz(self):
        sql = """CREATE TABLE IF NOT EXISTS quiz(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                driver_id BIGINT NOT NULL,
                datetime timestamp NOT NULL
                )"""
        await self.pool.execute(sql)

    async def _create_analise_client(self):
        sql = """CREATE TABLE IF NOT EXISTS analise_client(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL,
                from_town BIGINT,
                location Bool,
                
                to_town BIGINT,
                places BIGINT,
                no_model BOOL,
                to_district BIGINT,
                to_spot BIGINT,
                to_subspot BIGINT,
                filter_time BOOL,
                filter_money BOOL,
                filter_distance BOOL,

                ordered BOOL,
                phone BOOL,
                
                book BOOL,
                
                datetime_open timestamp
                )"""
        await self.pool.execute(sql)

    async def _create_analise_driver(self):
        sql = """CREATE TABLE IF NOT EXISTS analise_driver(
                id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL,
                to_cancel BOOL,
                to_delete BOOL,
                
                from_town BIGINT,
                location Bool,
                
                to_town BIGINT,
                to_district BIGINT,
                to_spot BIGINT,
                to_subspot BIGINT,

                price BIGINT,
                place BIGINT,
                date_time timestamp,

                book BOOL,
                datetime_open timestamp
                )"""
        await self.pool.execute(sql)

    async def create_table_transactions(self):
        sql4 = """CREATE TABLE IF NOT EXISTS transactions(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        paycom_transaction_id VARCHAR(25) NOT NULL, paycom_time VARCHAR(13) NOT NULL,
        paycom_time_datetime TIMESTAMP NOT NULL, create_time BIGINT NOT NULL,
        perform_time BIGINT NULL, cancel_time BIGINT NULL,
        amount BIGINT NOT NULL, state INT NOT NULL, reason INT NULL,
        receivers VARCHAR(500) NULL, order_id BIGINT 
        )"""
        await self.pool.execute(sql4)

    async def create_table_click_tran(self):
        sql9 = """CREATE TABLE IF NOT EXISTS click(
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        click_trans_id BIGINT,
        click_paydoc_id BIGINT,
        merchant_trans_id VARCHAR,
        amount BIGINT,
        action INT,
        sign_time VARCHAR,
        canceled BOOL
        )"""
        await self.pool.execute(sql9)

    # database
    async def add_spots(self, spots: list):
        sql = """INSERT INTO public.sub_spots (town_rus, district_rus, spot_rus, sub_spot_rus, 
                                               town_uzb, district_uzb, spot_uzb, sub_spot_uzb, 
                                               town_ozb, district_ozb, spot_ozb, sub_spot_ozb)
                 VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)"""
        await self.pool.executemany(sql, spots)

    async def add_relations(self, relation: list):
        for i in relation:
            sql = """INSERT INTO relationship (data)
                             VALUES($1)"""
            await self.pool.execute(sql, json.dumps(i))

    # exist
    async def exist_client(self, user_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.all_users WHERE user_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def exist_driver(self, driver_id: int):
        sql = """SELECT CASE WHEN
                EXISTS (SELECT * FROM public.drivers WHERE driver_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def exist_lang(self, user_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.all_users 
                WHERE user_id = $1 and language is not NULL)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def name_driver(self, driver_id: int):
        sql = """SELECT name FROM public.drivers WHERE driver_id = $1"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    # block_status
    async def block_status(self, user_id: int, status: bool):
        sql = """UPDATE public.all_users SET status = $2 WHERE user_id = $1"""
        await self.pool.execute(sql, user_id, status)

    # language
    async def select_language(self, user_id: int):
        sql = """ SELECT language FROM public.all_users 
                  WHERE user_id = $1 """
        return (await self.pool.fetchrow(sql, user_id))[0]

    async def update_language(self, language: str, user_id: int):
        sql = """UPDATE public.all_users SET language = $1 WHERE user_id = $2"""
        await self.pool.execute(sql, language, user_id)

    # first rec
    async def first_rec_client(self, user_id: int, name: str, username: str, status: bool):
        date = dt_now.now()
        sql = """INSERT INTO all_users (user_id, name, username, status, datetime_registration)
                 VALUES ($1, $2, $3, $4, $5)"""
        await self.pool.execute(sql, user_id, name, username, status, date)

    async def first_rec_driver(self, driver_id: int, name: str, username: str,
                               car: int, color: int, number: str, phone: int, wallet: int):
        date = dt_now.now()
        sql = """INSERT INTO public.drivers (driver_id, name, username, car, color, number,  phone, driver_rate,
                                             datetime_registration, wallet_main, wallet_bonus, wallet_holiday)
                 VALUES ($1, $2, $3, $4, $5, $6, $7, 5, $8, 0, $9, 0)"""
        await self.pool.execute(sql, driver_id, name, username, car, color, number, phone, date, wallet)

    # value_id & value
    async def id_and_town(self, language: str):
        if language == 'rus':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, TOWN_RUS FROM PUBLIC.SUB_SPOTS
                        GROUP BY TOWN_RUS ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql)
        elif language == 'uzb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, TOWN_UZB FROM PUBLIC.SUB_SPOTS
                        GROUP BY TOWN_UZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql)
        elif language == 'ozb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, TOWN_OZB FROM PUBLIC.SUB_SPOTS
                        GROUP BY TOWN_OZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql)

    async def id_to_town(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """SELECT TOWN_RUS  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'uzb':
            sql = """SELECT TOWN_UZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'ozb':
            sql = """SELECT TOWN_OZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]

    async def id_and_district(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, DISTRICT_RUS FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_RUS = (SELECT TOWN_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY DISTRICT_RUS ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'uzb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, DISTRICT_UZB FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_UZB = (SELECT TOWN_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY DISTRICT_UZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'ozb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, DISTRICT_OZB FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_OZB = (SELECT TOWN_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY DISTRICT_OZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)

    async def id_to_district(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """SELECT DISTRICT_RUS  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'uzb':
            sql = """SELECT DISTRICT_UZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'ozb':
            sql = """SELECT DISTRICT_OZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]

    async def id_and_spots(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_RUS FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_RUS = (SELECT TOWN_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_RUS ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'uzb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_UZB FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_UZB = (SELECT TOWN_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_UZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'ozb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_OZB FROM PUBLIC.SUB_SPOTS
                        WHERE TOWN_OZB = (SELECT TOWN_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_OZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)

    async def id_and_spots_city(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_RUS FROM PUBLIC.SUB_SPOTS
                        WHERE DISTRICT_RUS = (SELECT DISTRICT_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_RUS ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'uzb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_UZB FROM PUBLIC.SUB_SPOTS
                        WHERE DISTRICT_UZB = (SELECT DISTRICT_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_UZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'ozb':
            sql = """   SELECT MIN(SUB_ID) AS SUB_ID, SPOT_OZB FROM PUBLIC.SUB_SPOTS
                        WHERE DISTRICT_OZB = (SELECT DISTRICT_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        GROUP BY SPOT_OZB ORDER BY SUB_ID ASC"""
            return await self.pool.fetch(sql, sub_id)

    async def id_to_spot(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """SELECT SPOT_RUS  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'uzb':
            sql = """SELECT SPOT_UZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'ozb':
            sql = """SELECT SPOT_OZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]

    async def id_and_sub_spots(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """   SELECT SUB_ID, SUB_SPOT_RUS FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_RUS = (SELECT SPOT_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_RUS = (SELECT TOWN_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'uzb':
            sql = """   SELECT SUB_ID, SUB_SPOT_UZB FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_UZB = (SELECT SPOT_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_UZB = (SELECT TOWN_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'ozb':
            sql = """   SELECT SUB_ID, SUB_SPOT_OZB FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_OZB = (SELECT SPOT_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_OZB = (SELECT TOWN_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)

    async def district_id_and_sub_spots(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """   SELECT SUB_ID, SUB_SPOT_RUS FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_RUS = (SELECT SPOT_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_RUS = (SELECT TOWN_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND DISTRICT_RUS = (SELECT DISTRICT_RUS FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'uzb':
            sql = """   SELECT SUB_ID, SUB_SPOT_UZB FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_UZB = (SELECT SPOT_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_UZB = (SELECT TOWN_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND DISTRICT_UZB = (SELECT DISTRICT_UZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)
        elif language == 'ozb':
            sql = """   SELECT SUB_ID, SUB_SPOT_OZB FROM PUBLIC.SUB_SPOTS
                        WHERE SPOT_OZB = (SELECT SPOT_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)
                        AND TOWN_OZB = (SELECT TOWN_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1) 
                        AND DISTRICT_OZB = (SELECT DISTRICT_OZB FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1)"""
            return await self.pool.fetch(sql, sub_id)

    async def id_to_sub_spot(self, sub_id: int, language: str):
        if language == 'rus':
            sql = """SELECT SUB_SPOT_RUS  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'uzb':
            sql = """SELECT SUB_SPOT_UZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]
        elif language == 'ozb':
            sql = """SELECT SUB_SPOT_OZB  FROM PUBLIC.SUB_SPOTS WHERE SUB_ID = $1"""
            return (await self.pool.fetchrow(sql, sub_id))[0]

    # car id and value
    async def id_and_car(self):
        sql = 'SELECT * FROM public.cars'
        return await self.pool.fetch(sql)

    async def id_to_car(self, car_id):
        sql = 'SELECT car FROM public.cars WHERE car_id = $1'
        return (await self.pool.fetchrow(sql, car_id))[0]

    # основные параметры водителя
    async def select_parametrs_driver(self, driver_id):
        sql = 'SELECT name, phone, car, color, number, round(driver_rate, 1)::numeric FROM public.drivers WHERE driver_id = $1'
        return await self.pool.fetchrow(sql, driver_id)

    # personal data
    async def update_drivers_name(self, driver_id: int, name: str):
        sql = """   UPDATE public.drivers
                    SET  name = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, name)

    async def update_drivers_phone(self, driver_id: int, phone: int):
        sql = """   UPDATE public.drivers
                    SET  phone = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, phone)

    async def update_drivers_car(self, driver_id: int, car: int):
        sql = """   UPDATE public.drivers
                    SET  car = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, car)

    async def update_drivers_color(self, driver_id: int, color: int):
        sql = """   UPDATE public.drivers
                    SET  color = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, color)

    async def update_drivers_number(self, driver_id: int, number: str):
        sql = """   UPDATE public.drivers
                    SET  number = $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, number)

    # quiz
    async def exist_quiz(self, driver_id: int):
        sql = """SELECT CASE WHEN EXISTS (SELECT * FROM public.quiz WHERE driver_id = $1)
                THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def add_quiz(self, driver_id: int):
        # date = dt_now.now()
        date = dt_now.now()
        sql = """INSERT INTO public.quiz (driver_id, datetime)
                 VALUES($1, $2)"""
        await self.pool.execute(sql, driver_id, date)

    # wallet
    async def select_all_wallet(self, driver_id: int):
        sql = """SELECT WALLET_MAIN + WALLET_BONUS + WALLET_HOLIDAY AS WALLET_ALL 
                            FROM PUBLIC.DRIVERS
                            WHERE DRIVER_ID = $1"""
        return (await self.pool.fetchrow(sql, driver_id))[0]

    async def select_wallets(self, driver_id: int):
        sql = """SELECT WALLET_MAIN,
                    WALLET_BONUS + WALLET_HOLIDAY
                    FROM PUBLIC.DRIVERS
                    WHERE DRIVER_ID = $1"""
        return await self.pool.fetchrow(sql, driver_id)

    async def select_every_wallet(self, driver_id: int):
        sql = """SELECT WALLET_MAIN, WALLET_BONUS, WALLET_HOLIDAY
                    FROM PUBLIC.DRIVERS
                    WHERE DRIVER_ID = $1"""
        return await self.pool.fetchrow(sql, driver_id)

    # route
    async def route_exist(self, driver_id: int):
        date_time = dt_now.now()
        sql = """   SELECT CASE	
                    WHEN EXISTS (SELECT * FROM PUBLIC.ORDERS_DRIVER 
                                 WHERE DRIVER_ID = $1 
                                 AND CANCEL = FALSE 
                                 AND DATETIME_TRIP >= $2)
                    THEN TRUE 
                    ELSE FALSE 
                    END"""
        return (await self.pool.fetchrow(sql, driver_id, date_time))[0]

    async def route_parameters(self, driver_id: int):
        date_time = dt_now.now()
        sql = """    SELECT FROM_TOWN, TO_TOWN, TO_DISTRICT, TO_SUBSPOT,
                     DATETIME_TRIP, PLACES, PRICE
                     FROM PUBLIC.ORDERS_DRIVER
                     WHERE DRIVER_ID = $1 
                     AND CANCEL = FALSE 
                     AND DATETIME_TRIP >= $2 """
        return await self.pool.fetchrow(sql, driver_id, date_time)

    async def route_cancel(self, driver_id: int):
        date = dt_now.now()
        sql = """   UPDATE PUBLIC.ORDERS_DRIVER
                    SET CANCEL = TRUE, DATETIME_CLOSE = $2 
                    WHERE DRIVER_ID = $1 
                    AND CANCEL = FALSE"""
        await self.pool.execute(sql, driver_id, date)

    async def route_location(self, driver_id: int):
        date = dt_now.now()
        sql = """   SELECT LOCATION FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID = $1 
                    AND CANCEL = FALSE
                    AND datetime_trip > $2"""
        return json.loads((await self.pool.fetchrow(sql, driver_id, date))[0])

    async def active_location(self, order_accept_id: int):
        sql = """   SELECT LOCATION FROM PUBLIC.ORDERS_ACCEPTED
                    WHERE ORDER_ACCEPT_ID = $1 """
        return json.loads((await self.pool.fetchrow(sql, order_accept_id))[0])

    async def driver_location(self, order_driver_id: int):
        sql = """   SELECT LOCATION FROM PUBLIC.ORDERS_DRIVER  
                    WHERE ORDER_DRIVER_ID = $1 """
        return json.loads((await self.pool.fetchrow(sql, order_driver_id))[0])

    #

    async def select_count_to_town(self, from_town: int, to_town: int, places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $5 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2 
                              AND PLACES >= $3 
                             AND DATETIME_TRIP >= $4)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND PLACES >= $3 
                    AND DATETIME_TRIP >= $4  
                    AND CANCEL = FALSE """
        return (await self.pool.fetchrow(sql, from_town, to_town, places, date, client_id))[0]

    async def select_to_districts(self, from_town: int, to_town: int, places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT TO_DISTRICT, COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $5 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2 
                             AND PLACES >= $3 
                             AND DATETIME_TRIP >= $4)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND PLACES >= $3 
                    AND DATETIME_TRIP >= $4  
                    AND CANCEL = FALSE  
                    GROUP BY TO_DISTRICT"""
        return await self.pool.fetch(sql, from_town, to_town, places, date, client_id)

    async def select_count_to_districts(self, from_town: int, to_town: int, to_district: int, places: int,
                                        client_id: int):
        date = dt_now.now()
        sql = """   SELECT COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $6 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2 
                             AND TO_DISTRICT = $3 
                             AND PLACES >= $4 
                             AND DATETIME_TRIP >= $5)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND TO_DISTRICT = $3 
                    AND PLACES >= $4 
                    AND DATETIME_TRIP >= $5  
                    AND CANCEL = FALSE """
        return (await self.pool.fetchrow(sql, from_town, to_town, to_district, places, date, client_id))[0]

    async def select_to_spots(self, from_town: int, to_town: int, to_district: int, places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT TO_SPOT, COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $6 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2  
                             AND (TO_DISTRICT = $3 OR TO_DISTRICT IS NULL) 
                             AND PLACES >= $4
                             AND DATETIME_TRIP >= $5)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND (TO_DISTRICT = $3 OR TO_DISTRICT IS NULL) 
                    AND PLACES >= $4
                    AND DATETIME_TRIP >= $5  
                    AND CANCEL = FALSE  
                    GROUP BY TO_SPOT"""
        return await self.pool.fetch(sql, from_town, to_town, to_district, places, date, client_id)

    async def select_count_to_spots(self, from_town: int, to_town: int, to_spot: int, places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $6 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2  
                             AND TO_SPOT = $3 
                             AND PLACES >= $4
                             AND DATETIME_TRIP >= $5)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND TO_SPOT = $3 
                    AND PLACES >= $4
                    AND DATETIME_TRIP >= $5  
                    AND CANCEL = FALSE """
        return (await self.pool.fetchrow(sql, from_town, to_town, to_spot, places, date, client_id))[0]

    async def select_to_subspots(self, from_town: int, to_town: int, to_spot: int, places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT TO_SUBSPOT, COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $6 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2 
                             AND TO_SPOT = $3 
                             AND PLACES >= $4 
                             AND DATETIME_TRIP >= $5)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND TO_SPOT = $3 
                    AND PLACES >= $4 
                    AND DATETIME_TRIP >= $5 
                    AND CANCEL = FALSE  
                    GROUP BY TO_SUBSPOT"""
        return await self.pool.fetch(sql, from_town, to_town, to_spot, places, date, client_id)

    async def select_count_to_subspots(self, from_town: int, to_town: int, to_spot: int, to_subspot: int,
                                       places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $7 
                             AND FROM_TOWN = $1 
                             AND TO_TOWN = $2 
                             AND TO_SPOT = $3 
                             AND TO_SUBSPOT = $4
                             AND PLACES >= $5 
                             AND DATETIME_TRIP >= $6)
                    AND FROM_TOWN = $1 
                    AND TO_TOWN = $2 
                    AND TO_SPOT = $3 
                    AND TO_SUBSPOT = $4
                    AND PLACES >= $5 
                    AND DATETIME_TRIP >= $6 
                    AND CANCEL = FALSE"""
        return (await self.pool.fetchrow(sql, from_town, to_town, to_spot, to_subspot, places, date, client_id))[0]

    async def select_list(self, from_town: int, to_spot: int, to_subspot: int, places: int, client_id: int,
                          location: dict):
        date = dt_now.now()
        sql = """   SELECT FOO.ORDER_DRIVER_ID, FOO.PRICE, FOO.DATETIME_TRIP,  
                    (abs((3958 * 3.1415926 
                    * sqrt(($7 - (foo.location->>'latitude')::numeric)^2  + cos($7/ 57.29578) 
                    * cos((foo.location->>'latitude')::numeric / 57.29578) 
                    * ($8 - (foo.location->>'longitude')::numeric)^2) / 180) 
                    * 1.609344)) * 1000 ::BIGINT AS DISTANCE
                            FROM PUBLIC.ORDERS_DRIVER AS FOO
                            WHERE DRIVER_ID NOT IN  (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                                                     WHERE CLIENT_ID = $6 
                                                     AND FROM_TOWN = $1 
                                                     AND TO_SPOT = $2 
                                                     AND TO_SUBSPOT = $3 
                                                     AND PLACES >= $4  
                                                     AND DATETIME_TRIP >= $5)
                            AND FROM_TOWN = $1 
                            AND TO_SPOT = $2 
                            AND TO_SUBSPOT = $3 
                            AND PLACES >= $4 
                            AND DATETIME_TRIP >= $5 
                            AND CANCEL = FALSE 
                            ORDER BY FOO.DATETIME_TRIP"""
        return await self.pool.fetch(sql, from_town, to_spot, to_subspot, places, date, client_id,
                                     location['latitude'], location['longitude'])

    async def sort_money(self, from_town: int, to_spot: int, to_subspot: int, places: int, client_id: int,
                         location: dict):
        date = dt_now.now()
        sql = """   SELECT FOO.ORDER_DRIVER_ID, FOO.PRICE, FOO.DATETIME_TRIP,  
                    (abs((3958 * 3.1415926 
                    * sqrt(($7 - (foo.location->>'latitude')::numeric)^2  + cos($7/ 57.29578) 
                    * cos((foo.location->>'latitude')::numeric / 57.29578) 
                    * ($8 - (foo.location->>'longitude')::numeric)^2) / 180) 
                    * 1.609344)) * 1000 ::BIGINT AS DISTANCE
                            FROM PUBLIC.ORDERS_DRIVER AS FOO
                            WHERE DRIVER_ID NOT IN  (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                                                     WHERE CLIENT_ID = $6 
                                                     AND FROM_TOWN = $1 
                                                     AND TO_SPOT = $2 
                                                     AND TO_SUBSPOT = $3 
                                                     AND PLACES >= $4  
                                                     AND DATETIME_TRIP >= $5)
                            AND FROM_TOWN = $1 
                            AND TO_SPOT = $2 
                            AND TO_SUBSPOT = $3 
                            AND PLACES >= $4 
                            AND DATETIME_TRIP >= $5 
                            AND CANCEL = FALSE 
                            ORDER BY FOO.PRICE"""
        return await self.pool.fetch(sql, from_town, to_spot, to_subspot, places, date, client_id,
                                     location['latitude'], location['longitude'])

    async def sort_distance(self, from_town: int, to_spot: int, to_subspot: int, places: int, client_id: int,
                            location: dict):
        date = dt_now.now()
        sql = """   SELECT FOO.ORDER_DRIVER_ID, FOO.PRICE, FOO.DATETIME_TRIP, 
                    (abs((3958 * 3.1415926 
                    * sqrt(($7 - (foo.location->>'latitude')::numeric)^2  + cos($7/ 57.29578) 
                    * cos((foo.location->>'latitude')::numeric / 57.29578) 
                    * ($8 - (foo.location->>'longitude')::numeric)^2) / 180) 
                    * 1.609344)) * 1000 ::BIGINT AS DISTANCE
                            FROM PUBLIC.ORDERS_DRIVER AS FOO
                            WHERE DRIVER_ID NOT IN  (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                                                     WHERE CLIENT_ID = $6 
                                                     AND FROM_TOWN = $1 
                                                     AND TO_SPOT = $2 
                                                     AND TO_SUBSPOT = $3 
                                                     AND PLACES >= $4  
                                                     AND DATETIME_TRIP >= $5)
                            AND FROM_TOWN = $1 
                            AND TO_SPOT = $2 
                            AND TO_SUBSPOT = $3 
                            AND PLACES >= $4 
                            AND DATETIME_TRIP >= $5 
                            AND CANCEL = FALSE 
                            ORDER BY DISTANCE"""
        return await self.pool.fetch(sql, from_town, to_spot, to_subspot, places, date, client_id,
                                     location['latitude'], location['longitude'])

    async def select_count(self, from_spot: int, from_subspot: int, to_spot: int, to_subspot: int,
                           places: int, client_id: int):
        date = dt_now.now()
        sql = """   SELECT COUNT(*) FROM PUBLIC.ORDERS_DRIVER
                    WHERE DRIVER_ID NOT IN 
                            (SELECT DRIVER_ID FROM PUBLIC.ORDERS_CLIENT 
                             WHERE CLIENT_ID = $7 AND 
                             FROM_SPOT = $1 
                             AND TO_SPOT = $3 
                             AND PLACES >= $5 
                             AND DATETIME_TRIP >= $6)
                    AND FROM_SPOT = $1 
                    AND FROM_SUBSPOT = $2 
                    AND TO_SPOT = $3 
                    AND TO_SUBSPOT = $4 
                    AND PLACES >= $5 
                    AND DATETIME_TRIP >= $6 
                    AND CANCEL = FALSE  """
        return (await self.pool.fetchrow(sql, from_spot, from_subspot, to_spot, to_subspot, places, date, client_id))[0]

    async def select_order(self, order_driver_id: int):
        sql = """   SELECT driver_id, datetime_trip, places, price
                    FROM public.orders_driver
                    WHERE order_driver_id = $1"""
        return await self.pool.fetchrow(sql, order_driver_id)

    async def order_driver_rec(self, driver_id: int, from_town: int, location: dict, to_district: int,
                               to_town: int, to_spot: int, to_subspot: int, date_time: str, places: int, price: int):
        datetime_open = dt_now.now()
        location = json.dumps(location)
        date_time = datetime.datetime.strptime(date_time, "%Y-%m-%d %H:%M:%S")
        sql = """   INSERT INTO public.orders_driver(driver_id, from_town, location, to_district, 
                                                    to_town, to_spot, to_subspot, 
                                                     datetime_trip, places, price, datetime_open, cancel)
                    VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, False)"""
        await self.pool.execute(sql, driver_id, from_town, location, to_district, to_town, to_spot, to_subspot,
                                date_time, places, price, datetime_open)

    async def order_client_rec(self, order_driver_id: int, client_id: int, driver_id: int, phone: int,
                               from_town: int, location: dict, to_district: int,
                               to_town: int, to_spot: int, to_subspot: int,
                               date_time: str, places: int, price: int, cost: int):
        date = dt_now.now()
        location = json.dumps(location)
        date_time = datetime.datetime.strptime(date_time, "%Y-%m-%d %H:%M:%S")
        sql = """   INSERT INTO public.orders_client(
                                order_driver_id, client_id, driver_id, phone, from_town, location, to_district, 
                                to_town, to_spot, to_subspot, datetime_trip, places, price, cost, datetime_open)
                    VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) 
                    RETURNING order_client_id"""
        return (await self.pool.fetchrow(sql, order_driver_id, client_id, driver_id, phone, from_town, location,
                                         to_district, to_town, to_spot, to_subspot, date_time, places,
                                         price, cost, date))[0]

    async def order_accepted_rec(self, order_client_id: int, order_driver_id: int,
                                 client_id: int, driver_id: int, phone_client: int, phone_driver: int,
                                 from_town: int, location: dict, to_town: int, to_district: int,
                                 to_spot: int, to_subspot: int, date_time: str, places: int, price: int, cost: int):
        date = dt_now.now()
        location = json.dumps(location)
        date_time = datetime.datetime.strptime(date_time, "%Y-%m-%d %H:%M:%S")
        sql = """INSERT INTO public.orders_accepted(order_client_id, order_driver_id, client_id, driver_id, 
                                                    phone_client, phone_driver, from_town, location, to_town, 
                                                    to_district, to_spot,  to_subspot, datetime_trip, places, price, 
                                                    cost, datetime_accepted)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                RETURNING order_accept_id"""
        return (await self.pool.fetchrow(sql, order_client_id, order_driver_id, client_id, driver_id, phone_client,
                                         phone_driver, from_town, location, to_town, to_district, to_spot, to_subspot,
                                         date_time, places, price, cost, date))[0]

    async def delay_passenger(self, order_client_id):
        sql = """   UPDATE public.orders_client
                    SET  order_accept = False
                    WHERE order_client_id = $1 and order_accept is Null"""
        await self.pool.execute(sql, order_client_id)

    async def check_order_accept(self, order_client_id: int):
        sql = """SELECT order_accept FROM public.orders_client 
                 WHERE order_client_id = $1 """
        return (await self.pool.fetchrow(sql, order_client_id))[0]

    async def check_order_accept2(self, client_id: int, from_town: int, to_town: int):
        date = dt_now.now()
        sql = """SELECT order_accept FROM public.orders_client 
                 WHERE client_id = $1 
                 AND from_town = $2 
                 AND to_town = $3 
                 AND datetime_trip >= $4 """
        return (await self.pool.fetchrow(sql, client_id, from_town, to_town, date))[0]

    async def new_order_client(self, order_client_id: int):
        sql = """SELECT phone, from_town, location, to_town, to_district, to_spot, to_subspot, datetime_trip, places 
                 FROM public.orders_client WHERE order_client_id = $1 """
        return await self.pool.fetchrow(sql, order_client_id)

    # выбор ордера водителем, который сделал клиент
    async def new_order_driver(self, order_client_id: int):
        sql = """SELECT order_driver_id, client_id, from_town, location,
                        to_town, to_district, to_spot, to_subspot, datetime_trip, places, price, cost, phone 
                  FROM public.orders_client WHERE order_client_id = $1"""
        return await self.pool.fetchrow(sql, order_client_id)

    # проверка статуса принятия ордера
    async def select_order_client_check(self, order_client_id: int):
        sql = """SELECT CASE WHEN
                 EXISTS (SELECT order_accept FROM public.orders_client 
                 WHERE order_client_id=$1 AND order_accept IS NULL)
                 THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, order_client_id))[0]

    # проверка статуса принятия ордера
    async def select_order_accept_check(self, order_accept_id: int):
        sql = """SELECT CASE WHEN
                 EXISTS (SELECT * FROM public.orders_accepted 
                 WHERE order_accept_id = $1 AND datetime_cancel IS NULL)
                 THEN TRUE ELSE FALSE END"""
        return (await self.pool.fetchrow(sql, order_accept_id))[0]

    async def update_orders_client_accepted(self, order_client_id: int):
        sql = """UPDATE public.orders_client SET order_accept = TRUE WHERE order_client_id = $1 """
        await self.pool.execute(sql, order_client_id)

    async def update_orders_client_rejected(self, order_client_id: int):
        sql = """UPDATE public.orders_client SET order_accept = FALSE WHERE order_client_id = $1 """
        await self.pool.execute(sql, order_client_id)

    async def update_orders_client_cancel(self, client_id: int, from_town: int, to_town: int, order_driver_id: int):
        date = dt_now.now()
        sql = """UPDATE public.orders_client 
                        SET order_accept = FALSE  
                        WHERE client_id = $1 
                        AND from_town = $2 
                        AND to_town = $3 
                        AND order_driver_id != $4
                        AND datetime_trip >= $5"""
        await self.pool.execute(sql, client_id, from_town, to_town, order_driver_id, date)

    # places
    async def update_order_driver_add_places(self, order_driver_id, places):
        sql = """   UPDATE public.orders_driver
                    SET  places = (SELECT places FROM public.orders_driver WHERE order_driver_id = $1) - $2
                    WHERE order_driver_id = $1 """
        await self.pool.execute(sql, order_driver_id, places)

    async def update_order_driver_remove_places(self, order_driver_id: int, places: int):
        sql = """   UPDATE public.orders_driver
                    SET  places = (SELECT places FROM public.orders_driver WHERE order_driver_id = $1) + $2
                    WHERE order_driver_id = $1 """
        await self.pool.execute(sql, order_driver_id, places)

    async def check_places_orders_driver(self, order_driver_id: int):
        sql = """   SELECT places FROM public.orders_driver 
                    WHERE order_driver_id = $1 """
        return (await self.pool.fetchrow(sql, order_driver_id))[0]

    async def cancel_active_order(self, order_accept_id: int, driver=False, client=False):
        sql = """UPDATE public.orders_accepted 
                SET cancel_driver = $2, cancel_client = $3, datetime_cancel = CURRENT_TIMESTAMP(2)
                WHERE order_accept_id = $1"""
        await self.pool.execute(sql, order_accept_id, driver, client)

    # выбор всех ордеров водителя по одному направлению, дате, и типу поездки
    async def select_order_accept_driver(self, driver_id: int, date_time: str,
                                         from_town: int, from_spot: int, from_subspot: int,
                                         to_town: int, to_spot: int, to_subspot: int):
        date_time = datetime.datetime.strptime(date_time, "%Y-%m-%d %H:%M:%S")
        sql = """SELECT order_accept_id, client_id, cost, places
                 FROM public.orders_accepted
                 WHERE driver_id = $1 AND date_time = $2 
                 AND  from_town = $3 AND from_spot = $4 AND from_subspot = $5
                 AND  to_town = $6 AND to_spot = $7 AND to_subspot = $8 
                 AND datetime_cancel is NULL """
        return await self.pool.fetch(sql, driver_id, date_time,
                                     from_town, from_spot, from_subspot, to_town, to_spot, to_subspot)

    async def update_driver_wallet_accept(self, driver_id: int, wallet):
        wallet_main, wallet_bonus, wallet_holiday = wallet
        print(wallet_main, wallet_bonus, wallet_holiday)
        sql = """   UPDATE public.drivers
                    SET   wallet_main=$2 , wallet_bonus=$3 , wallet_holiday=$4
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, wallet_main, wallet_bonus, wallet_holiday)

    # выбор ордера по ордер айди
    async def orderid_to_order_accepted(self, order_accept_id):
        sql = """ SELECT order_client_id, client_id, order_driver_id, driver_id, phone_client, 
                  from_town, to_town, to_district, to_subspot, datetime_trip, places, price, cost 
                  FROM public.orders_accepted 
                  WHERE order_accept_id = $1"""
        return await self.pool.fetchrow(sql, order_accept_id)

    async def update_driver_wallet_payment(self, driver_id: int, cash: int):
        sql = """   UPDATE public.drivers
                    SET  wallet_main = (SELECT wallet_main FROM public.drivers WHERE driver_id = $1) + $2
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, cash)

    # active order client
    async def check_active_order_client(self, client_id):
        date = dt_now.now() - datetime.timedelta(minutes=10)
        sql = """SELECT CASE WHEN
                 EXISTS(SELECT * FROM public.orders_accepted 
                 WHERE client_id = $1 AND datetime_trip >= $2 AND datetime_cancel is Null)
                 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, client_id, date))[0]

    # active order driver
    async def check_active_order_driver(self, driver_id):
        date = dt_now.now() - datetime.timedelta(minutes=10)
        sql = """SELECT CASE WHEN
                 EXISTS(SELECT * FROM public.orders_accepted 
                 WHERE driver_id = $1 AND datetime_trip >= $2 AND datetime_cancel is Null)
                 THEN TRUE ELSE FALSE END """
        return (await self.pool.fetchrow(sql, driver_id, date))[0]

    async def select_order_accepted_to_client_expired(self, client_id):
        date_trip = dt_now.now() - datetime.timedelta(minutes=10)
        date_now = dt_now.now()
        sql = """SELECT order_accept_id 
                  FROM public.orders_accepted 
                  WHERE client_id = $1 AND datetime_trip >= $2 AND datetime_trip <= $3 AND datetime_cancel is NULL
                  ORDER BY datetime_trip"""
        return await self.pool.fetch(sql, client_id, date_trip, date_now)

    async def select_order_accepted_to_client_not_expired(self, client_id):
        date = dt_now.now()
        sql = """SELECT order_accept_id 
                  FROM public.orders_accepted 
                  WHERE client_id = $1 AND datetime_trip > $2 AND datetime_cancel is NULL 
                  ORDER BY datetime_trip"""
        return await self.pool.fetch(sql, client_id, date)

    async def select_order_accepted_to_driver_expired(self, driver_id):
        date_trip = dt_now.now() - datetime.timedelta(minutes=10)
        date_now = dt_now.now()
        sql = """SELECT order_accept_id 
                  FROM public.orders_accepted 
                  WHERE driver_id = $1 AND datetime_trip >= $2 AND datetime_trip <= $3 AND datetime_cancel is NULL
                  ORDER BY datetime_trip"""
        return await self.pool.fetch(sql, driver_id, date_trip, date_now)

    async def select_order_accepted_to_driver_not_expired(self, driver_id):
        date = dt_now.now()
        sql = """SELECT order_accept_id 
                  FROM public.orders_accepted 
                  WHERE driver_id = $1 AND datetime_trip > $2 AND datetime_cancel is NULL 
                  ORDER BY datetime_trip"""
        return await self.pool.fetch(sql, driver_id, date)

    async def select_order_driver(self, driver_id):
        date = dt_now.now() - datetime.timedelta(minutes=10)
        sql = """SELECT order_driver_id 
                  FROM public.orders_driver 
                  WHERE driver_id = $1 AND datetime_trip > $2 
                  AND cancel = False 
                  AND order_driver_id in (SELECT order_driver_id FROM public.orders_accepted 
                                          WHERE driver_id = $1 AND datetime_trip > $2 
                                          AND datetime_cancel is Null)
                  ORDER BY datetime_trip"""
        return await self.pool.fetch(sql, driver_id, date)

    async def orderid_to_order_driver(self, order_driver_id):
        sql = """ SELECT DRIVERS.PHONE, FOO.DRIVER_ID, FOO.FROM_TOWN, FOO.DATETIME_TRIP
                  FROM (SELECT * FROM PUBLIC.ORDERS_DRIVER
                        WHERE ORDER_DRIVER_ID = $1) AS FOO
                  LEFT JOIN PUBLIC.DRIVERS ON DRIVERS.DRIVER_ID = FOO.DRIVER_ID"""
        return await self.pool.fetchrow(sql, order_driver_id)

    async def orderid_to_clients(self, order_driver_id):
        sql = """ SELECT phone_client, client_id FROM public.orders_accepted 
                  WHERE order_driver_id = $1"""
        return await self.pool.fetch(sql, order_driver_id)

    async def update_drivers_rate(self, order_accept_id: int, rate: int):
        sql = """   UPDATE public.orders_accepted 
                    SET driver_rate = $2 
                    WHERE order_accept_id = $1 
                    RETURNING driver_id"""
        return (await self.pool.fetchrow(sql, order_accept_id, rate))[0]

    async def select_drivers_rate(self, order_accept_id: int):
        sql = """   SELECT DRIVER_RATE
                    FROM PUBLIC.ORDERS_ACCEPTED
                    WHERE DRIVER_ID = (SELECT DRIVER_ID FROM PUBLIC.ORDERS_ACCEPTED
                                        WHERE ORDER_ACCEPT_ID = $1)
                    AND DRIVER_RATE IS NOT NULL
                    ORDER BY ORDER_ACCEPT_ID DESC"""
        return await self.pool.fetch(sql, order_accept_id)

    async def update_drivers_new_rate(self, driver_id: int, new_rate):
        sql = """   UPDATE public.drivers 
                    SET driver_rate = $2 
                    WHERE driver_id = $1 """
        await self.pool.execute(sql, driver_id, new_rate)

    # first bonus
    async def time_reminder(self, days: int):
        date = dt_now.now()
        sql = f""" SELECT DRIVERS.DRIVER_ID,
                         DRIVERS.WALLET_BONUS,
                         DATE(DRIVERS.DATETIME_REGISTRATION + interval '20 day'),
                         ALL_USERS.LANGUAGE
                        FROM PUBLIC.DRIVERS
                   LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                   WHERE DATE(DRIVERS.DATETIME_REGISTRATION + interval '{20 - days} day') = $1"""
        return await self.pool.fetch(sql, date)

    async def bonus_end(self):
        date = dt_now.now()
        sql = """   UPDATE PUBLIC.DRIVERS
                    SET WALLET_BONUS = 0
                    WHERE DATE(DATETIME_REGISTRATION + interval '21 day') = $1 """
        await self.pool.execute(sql, date)

    # analise client
    async def insert_analise_client(self, user_id: int):
        date = dt_now.now()
        sql = """INSERT into public.analise_client(user_id, datetime_open) 
                 VALUES($1, $2) RETURNING id"""
        return (await self.pool.fetchrow(sql, user_id, date))[0]

    async def update_from_town_client(self, row_id: int, from_town: int):
        sql = """UPDATE public.analise_client 
                 SET from_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, from_town)

    async def update_location_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET location = True 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_to_town_client(self, row_id: int, to_town: int):
        sql = """UPDATE public.analise_client 
                 SET to_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_town)

    async def update_no_model_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET no_model = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_to_district_client(self, row_id: int, to_district: int):
        sql = """UPDATE public.analise_client 
                 SET to_district = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_district)

    async def update_to_spot_client(self, row_id: int, to_spot: int):
        sql = """UPDATE public.analise_client 
                 SET to_spot = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_spot)

    async def update_to_subspot_client(self, row_id: int, to_subspot: int):
        sql = """UPDATE public.analise_client 
                 SET to_subspot = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_subspot)

    async def update_filters1_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET filter_time = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_filters2_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET filter_money = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_filters3_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET filter_distance = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_places_client(self, row_id: int, places: int):
        sql = """UPDATE public.analise_client 
                 SET places = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, places)

    async def update_ordered_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET ordered = True
                 WHERE id = $1 """
        await self.pool.execute(sql, row_id)

    async def update_phone_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET phone = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_book_client(self, row_id: int):
        sql = """UPDATE public.analise_client 
                 SET book = TRUE
                 WHERE id = $1 AND book IS NULL"""
        await self.pool.execute(sql, row_id)

    # analise driver
    async def insert_analise_driver(self, driver_id: int):
        date = dt_now.now()
        sql = """INSERT into public.analise_driver(user_id, datetime_open) 
                 VALUES($1, $2) RETURNING id"""
        return (await self.pool.fetchrow(sql, driver_id, date))[0]

    async def update_from_town_driver(self, row_id: int, from_town: int):
        sql = """UPDATE public.analise_driver 
                 SET from_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, from_town)

    async def update_location_driver(self, row_id: int):
        sql = """UPDATE public.analise_driver 
                 SET location = True 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_to_town_driver(self, row_id: int, to_town: int):
        sql = """UPDATE public.analise_driver 
                 SET to_town = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_town)

    async def update_to_district_driver(self, row_id: int, to_district: int):
        sql = """UPDATE public.analise_driver 
                 SET to_district = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_district)

    async def update_to_spot_driver(self, row_id: int, to_spot: int):
        sql = """UPDATE public.analise_driver 
                 SET to_spot = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_spot)

    async def update_to_subspot_driver(self, row_id: int, to_subspot: int):
        sql = """UPDATE public.analise_driver 
                 SET to_subspot = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, to_subspot)

    async def update_price_driver(self, row_id: int, price: int):
        sql = """UPDATE public.analise_driver 
                 SET price = $2
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, price)

    async def update_places_driver(self, row_id: int, places: int):
        sql = """UPDATE public.analise_driver 
                 SET place = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, places)

    async def update_datetime_driver(self, row_id: int, date_time: str):
        date_time = datetime.datetime.strptime(date_time, "%Y-%m-%d %H:%M:%S")
        sql = """UPDATE public.analise_driver 
                 SET date_time = $2 
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id, date_time)

    async def update_book_driver(self, row_id: int):
        sql = """UPDATE public.analise_driver 
                 SET book = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_cancel_driver(self, row_id: int):
        sql = """UPDATE public.analise_driver 
                 SET to_cancel = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    async def update_delete_driver(self, row_id: int):
        sql = """UPDATE public.analise_driver 
                 SET to_delete = TRUE
                 WHERE id = $1"""
        await self.pool.execute(sql, row_id)

    # summary
    # users
    async def all_users(self):
        sql = """SELECT COUNT(*) FROM public.all_users"""
        return (await self.pool.fetchrow(sql))[0]

    async def new_users(self):
        date = dt_now.now()
        sql = """SELECT COUNT(*) FROM public.all_users WHERE date(datetime_registration) = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    # drivers
    async def all_drivers(self):
        sql = """SELECT COUNT(*) FROM public.drivers"""
        return (await self.pool.fetchrow(sql))[0]

    async def new_drivers(self):
        date = dt_now.now()
        sql = """SELECT COUNT(*) FROM public.drivers WHERE date(datetime_registration) = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    # payment
    async def all_payment(self):
        sql = """SELECT COALESCE(SUM(cash),0)::bigint, COALESCE(MAX(cash),0), COALESCE(MIN(cash),0), COUNT(*) 
                FROM public.wallet_pay WHERE status = TRUE"""
        return await self.pool.fetchrow(sql)

    async def new_payment(self):
        date = dt_now.now()
        sql = """SELECT COALESCE(SUM(cash),0)::bigint, COALESCE(MAX(cash), 0), COALESCE(MIN(cash),0), COUNT(*) 
                FROM public.wallet_pay WHERE date(datetime_payment) = $1 AND status = TRUE"""
        return await self.pool.fetchrow(sql, date)

    async def all_payment_type(self):
        sql = """SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Click' AND status = TRUE
                union all SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Payme' AND status = TRUE
                union all SELECT COUNT(*) FROM public.wallet_pay WHERE type_of_payment='Paynet' AND status = TRUE"""
        return await self.pool.fetch(sql)

    async def all_orders_success(self):
        date = dt_now.now()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE datetime_cancel IS Null AND datetime_trip < $1 """
        return (await self.pool.fetchrow(sql, date))[0]

    async def new_orders_success(self):
        date = dt_now.now() - datetime.timedelta(days=1)
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE datetime_cancel IS Null AND datetime_trip = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    async def all_order_cancel_client(self):
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_client=True """
        return (await self.pool.fetchrow(sql))[0]

    async def new_order_cancel_client(self):
        date = dt_now.now()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_client=True AND date(datetime_cancel) = $1"""
        return (await self.pool.fetchrow(sql, date))[0]

    async def all_order_cancel_driver(self):
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE  cancel_driver=True """
        return (await self.pool.fetchrow(sql))[0]

    async def new_order_cancel_driver(self):
        date = dt_now.now()
        sql = """SELECT COUNT(*) FROM public.orders_accepted 
                WHERE cancel_driver=True  AND date(datetime_cancel) = $1 """
        return (await self.pool.fetchrow(sql, date))[0]

    async def cancel_by_client(self):
        sql = """SELECT COALESCE(MAX(n),0), COALESCE(MIN(n),0), COALESCE(AVG(n)::numeric(6,2), 0)
                FROM (SELECT client_id, count(*) as n FROM public.orders_accepted
                WHERE cancel_client=True GROUP BY client_id) AS tbl"""
        return await self.pool.fetchrow(sql)

    async def cancel_by_driver(self):
        sql = """SELECT COALESCE(MAX(n),0), COALESCE(MIN(n),0), COALESCE(AVG(n)::numeric(6,2), 0)
                FROM (SELECT driver_id, count(*) as n FROM public.orders_accepted
                WHERE cancel_driver=True GROUP BY driver_id) AS tbl"""
        return await self.pool.fetchrow(sql)

    # admin
    async def get_users(self, users: str):
        if users == "client":
            return await self.get_clients()
        elif users == "driver":
            return await self.get_driver()
        elif users == 'all':
            return await self.get_all()

    async def get_clients(self):
        sql = """SELECT user_id FROM public.all_users WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)"""
        return await self.pool.fetch(sql)

    async def get_driver(self):
        sql = """SELECT driver_id FROM public.drivers"""
        return await self.pool.fetch(sql)

    async def get_all(self):
        sql = """SELECT user_id FROM public.all_users"""
        return await self.pool.fetch(sql)

    async def get_users_unblock(self, users: str):
        if users == "client":
            return await self.get_clients_unblock()
        elif users == "driver":
            return await self.get_driver_unblock()
        elif users == 'all':
            return await self.get_all_unblock()

    async def get_clients_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.all_users 
                     WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)
                     AND status = TRUE 
                 UNION ALL
                    (SELECT COUNT(*) FROM public.all_users 
                     WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)
                     AND status = FALSE)"""
        return await self.pool.fetch(sql)

    async def get_driver_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.drivers
                    LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                    WHERE ALL_USERS.STATUS = TRUE
                UNION ALL
                    (SELECT COUNT(*) FROM public.drivers
                    LEFT JOIN PUBLIC.ALL_USERS ON ALL_USERS.USER_ID = DRIVERS.DRIVER_ID
                    WHERE ALL_USERS.STATUS = FALSE)
                """
        return await self.pool.fetch(sql)

    async def get_all_unblock(self):
        sql = """   SELECT COUNT(*) FROM public.all_users WHERE status = TRUE
                UNION ALL
                    (SELECT COUNT(*) FROM public.all_users WHERE status = FALSE)"""
        return await self.pool.fetch(sql)

    # ##################################### payments ###################################################################
    async def wallet_pay(self, driver_id: int, cash: int, type_of_payment: str, status: bool):
        datenow = dt_now.now()
        sql = """INSERT INTO public.wallet_pay(driver_id, cash, type_of_payment, datetime_payment, status)
                 VALUES ($1, $2, $3, $4, $5) RETURNING pay_id"""
        return (await self.pool.fetchrow(sql, driver_id, cash, type_of_payment, datenow, status))[0]

    async def update_status(self, status: bool, transaction_id: str):
        sql = """UPDATE wallet_pay SET status = $1 WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $2)"""
        await self.pool.execute(sql, status, transaction_id)

    # Payme
    # async def start_order_from_check(self, check: InsertCreatedCheck):
    #     sql = """INSERT INTO transactions(paycom_transaction_id,
    #                                       paycom_time,
    #                                       paycom_time_datetime,
    #                                       create_time,
    #                                       perform_time,
    #                                       cancel_time,
    #                                       amount,
    #                                       state,
    #                                       reason,
    #                                       receivers,
    #                                       order_id
    #                                       ) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11);"""
    #     await self.pool.execute(sql, *check)

    async def get_order(self, order_id: str) -> int or bool:
        sql = """SELECT order_id FROM transactions WHERE order_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, int(order_id))][0]
        except TypeError:
            return False

    async def get_state(self, order_id: str) -> int:
        sql = """SELECT state FROM transactions WHERE order_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, int(order_id))][0]
        except TypeError:
            return 10

    async def get_state_by_transaction_id(self, transaction_id: str) -> int:
        sql = """SELECT state FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_amount(self, order_id: str) -> int:
        sql = """SELECT amount FROM transactions WHERE order_id = $1"""
        return [*await self.pool.fetchrow(sql, int(order_id))][0]

    async def select_cash(self, transaction_id: str):
        sql = """SELECT amount FROM transactions WHERE paycom_transaction_id = $1"""
        return int([*await self.pool.fetchrow(sql, transaction_id)][0]/100)

    async def select_current_driver_cash(self, transaction_id: str):
        sql = """SELECT wallet_main FROM drivers WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $1))"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def update_cash_to_wallet(self, cash: int, transaction_id: str):
        sql = """UPDATE drivers SET wallet_main = $1 WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = (
        SELECT order_id FROM transactions WHERE paycom_transaction_id = $2))"""
        await self.pool.execute(sql, cash, transaction_id)

    async def get_transaction_id(self, transaction_id: str, order_id: str) -> bool:
        sql = """SELECT paycom_transaction_id FROM transactions WHERE paycom_transaction_id = $1 and order_id = $2"""
        return bool(await self.pool.fetchrow(sql, transaction_id, int(order_id)))

    async def get_transaction_by_id(self, transaction_id: str) -> bool:
        sql = """SELECT paycom_transaction_id FROM transactions WHERE paycom_transaction_id = $1"""
        return bool(await self.pool.fetchrow(sql, transaction_id))

    async def get_transaction(self, order_id: str) -> str:
        sql = """SELECT id FROM transactions WHERE order_id = $1"""
        return str([*await self.pool.fetchrow(sql, int(order_id))][0])

    async def get_transaction_incr(self, transaction_id: str) -> str:
        sql = """SELECT id FROM transactions WHERE paycom_transaction_id = $1"""
        return str([*await self.pool.fetchrow(sql, transaction_id)][0])

    async def get_create_time(self, order_id: str, transaction_id: str) -> int:
        sql = """SELECT create_time FROM transactions WHERE order_id = $1 and paycom_transaction_id = $2"""
        return [*await self.pool.fetchrow(sql, int(order_id), transaction_id)][0]

    async def get_create_time_by_transaction_id(self, transaction_id: str) -> int:
        sql = """SELECT create_time FROM transactions WHERE paycom_transaction_id = $1"""
        try:
            return [*await self.pool.fetchrow(sql, transaction_id)][0]
        except TypeError:
            return False

    async def get_perform_time(self, transaction_id):
        sql = """SELECT perform_time FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_cancel_time(self, transaction_id):
        sql = """SELECT cancel_time FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_reason(self, transaction_id: str):
        sql = """SELECT reason FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    async def get_user_id(self, transaction_id: str):
        sql = """SELECT order_id FROM transactions WHERE paycom_transaction_id = $1"""
        sql1 = f"""SELECT driver_id FROM wallet_pay WHERE pay_id = ({sql})"""
        return [*await self.pool.fetchrow(sql1, transaction_id)][0]

    async def from_to(self, from_: int, to: int):
        sql = """SELECT paycom_transaction_id, 
                        paycom_time, 
                        amount, 
                        order_id,
                        create_time,
                        perform_time,
                        cancel_time,
                        id,
                        state,
                        reason FROM transactions WHERE create_time > $1 and create_time < $2"""
        return await self.pool.fetch(sql, from_, to)

    async def update_state(self, state: int, order_id: str):
        sql = """UPDATE transactions SET state = $1 WHERE order_id = $2"""
        await self.pool.execute(sql, state, int(order_id))

    async def update_state_by_transaction_id(self, state: int, transaction_id: str):
        sql = """UPDATE transactions SET state = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, state, transaction_id)

    async def update_transaction_id(self, transaction_id: str, order_id: str):
        sql = """UPDATE transactions SET paycom_transaction_id = $1 WHERE order_id = $2"""
        await self.pool.execute(sql, transaction_id, int(order_id))

    async def update_reason(self, reason: int, order_id: str, transaction_id: str):
        sql = """UPDATE transactions SET reason = $1 WHERE order_id = $2 and paycom_transaction_id = $3"""
        await self.pool.execute(sql, reason, int(order_id), transaction_id)

    async def update_reason_by_transaction_id(self, reason: int, transaction_id: str):
        sql = """UPDATE transactions SET reason = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, reason, transaction_id)

    async def update_create_time(self, create_time: int, order_id: str, transaction_id: str):
        sql = """UPDATE transactions SET create_time = $1 WHERE order_id = $2 and paycom_transaction_id = $3"""
        await self.pool.execute(sql, create_time, int(order_id), transaction_id)

    async def update_perform_time(self, perform_time, transaction_id: str):
        sql = """UPDATE transactions SET perform_time = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, perform_time, transaction_id)

    async def update_cansel_time(self, cansel_time: int, transaction_id: str):
        sql = """UPDATE transactions SET cancel_time = $1 WHERE paycom_transaction_id = $2"""
        await self.pool.execute(sql, cansel_time, transaction_id)

    async def get_order_id_from_transaction_id(self, transaction_id: str):
        sql = """SELECT order_id FROM transactions WHERE paycom_transaction_id = $1"""
        return [*await self.pool.fetchrow(sql, transaction_id)][0]

    # Click
    async def add_click_order(self, order: InsertCreatedOrder):
        sql = """INSERT into click(click_trans_id, 
                                   click_paydoc_id, 
                                   merchant_trans_id, 
                                   amount,
                                   action,
                                   sign_time,
                                   canceled
                                   ) VALUES($1, $2, $3, $4, $5, $6, $7);"""
        await self.pool.execute(sql, *order)

    async def update_prepare_parameters(self, update: PrepareUpdate):
        sql = """UPDATE click SET click_trans_id = $1, click_paydoc_id = $2, action = $3, sign_time = $4 
                 WHERE merchant_trans_id = $5"""
        await self.pool.execute(sql, *update)

    async def select_prepare_id(self, merchant_trans_id: str) -> int:
        sql = """SELECT id FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_sign_time(self, merchant_trans_id: str) -> int:
        sql = """SELECT sign_time FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_amount(self, merchant_trans_id: str) -> int:
        sql = """SELECT amount FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_action(self, merchant_trans_id: str) -> int:
        sql = """SELECT action FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def update_complete_parameters(self, action: int, sign_time: str, merchant_trans_id: str):
        sql = """UPDATE click SET action = $1, sign_time = $2
                 WHERE merchant_trans_id = $3"""
        await self.pool.execute(sql, action, sign_time, merchant_trans_id)

    async def select_canceled(self, merchant_trans_id: str) -> int:
        sql = """SELECT canceled FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def update_status_click(self, status: bool, merchant_trans_id: str):
        sql = """UPDATE wallet_pay SET status = $1 WHERE pay_id = $2"""
        await self.pool.execute(sql, status, int(merchant_trans_id))

    async def update_cash_to_wallet_click(self, cash: int, merchant_trans_id: str):
        sql = """UPDATE drivers SET wallet_main = $1 WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = $2)"""
        await self.pool.execute(sql, cash, int(merchant_trans_id))

    async def select_cash_click(self, merchant_trans_id: str):
        sql = """SELECT amount FROM click WHERE merchant_trans_id = $1"""
        return [*await self.pool.fetchrow(sql, merchant_trans_id)][0]

    async def select_current_cash_driver(self, merchant_trans_id: str):
        sql = """SELECT wallet_main FROM drivers WHERE driver_id = (
        SELECT driver_id FROM wallet_pay WHERE pay_id = $1)"""
        return [*await self.pool.fetchrow(sql, int(merchant_trans_id))][0]

    async def get_user_id_click(self, merchant_trans_id: str):
        sql = """SELECT driver_id FROM wallet_pay WHERE pay_id = $1"""
        return [*await self.pool.fetchrow(sql, int(merchant_trans_id))][0]

    async def update_cancel_trans(self, cancel: bool, merchant_trans_id: str):
        sql = """UPDATE click SET canceled = $1 WHERE merchant_trans_id = $2"""
        await self.pool.execute(sql, cancel, merchant_trans_id)

    # every day
    async def every_day_client(self):
        sql = """ SELECT USER_ID FROM PUBLIC.ALL_USERS 
                  WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)"""
        return await self.pool.fetch(sql)

    async def every_day_driver(self):
        sql = " SELECT DRIVER_ID FROM PUBLIC.DRIVERS"
        return await self.pool.fetch(sql)

    async def analise_taxi_all_time(self):
        sql = """	SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FROM_TOWN IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE LOCATION IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_TOWN IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE PLACES IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE NO_MODEL IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_DISTRICT IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_SPOT IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_SUBSPOT IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_TIME IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_MONEY IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_DISTANCE IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE ORDERED IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE PHONE IS NOT NULL
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE BOOK IS NOT NULL """
        return await self.pool.fetch(sql)

    async def analise_taxi_timeframe(self, days: int):
        date = dt_now.now().date() - datetime.timedelta(days=days)
        sql = """  SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FROM_TOWN IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE LOCATION IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_TOWN IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE PLACES IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE NO_MODEL IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_DISTRICT IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_SPOT IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE TO_SUBSPOT IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_TIME IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_MONEY IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE FILTER_DISTANCE IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE ORDERED IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE PHONE IS NOT NULL AND date(datetime_open) >= $1
                    UNION ALL
                    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_CLIENT
                    WHERE BOOK IS NOT NULL  AND date(datetime_open) >= $1 """
        return await self.pool.fetch(sql, date)

    async def count_clients(self):
        # sql = """SELECT COUNT(*) FROM public.all_users"""
        sql = """SELECT COUNT(*) FROM public.all_users WHERE user_id NOT IN (SELECT driver_id FROM public.drivers)"""
        return (await self.pool.fetchrow(sql))[0]

    async def count_drivers(self):
        sql = """SELECT COUNT(*) FROM public.drivers"""
        return (await self.pool.fetchrow(sql))[0]

    async def analise_online_all_time(self):
        sql = """	    SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE FROM_TOWN IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE LOCATION IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_TOWN IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_DISTRICT IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_SPOT IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_SUBSPOT IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE PRICE IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE PLACE IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE DATE_TIME IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE BOOK IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_CANCEL IS NOT NULL)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_DELETE IS NOT NULL) 
        """
        return await self.pool.fetch(sql)

    async def analise_online_timeframe(self, days: int):
        date = dt_now.now().date() - datetime.timedelta(days=days)
        sql = """		SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE  date(datetime_open) >= $1
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE FROM_TOWN IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE LOCATION IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_TOWN IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_DISTRICT IS NOT NULL AND date(datetime_open) >= $1) 
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_SPOT IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_SUBSPOT IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE PRICE IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE PLACE IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE DATE_TIME IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE BOOK IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_CANCEL IS NOT NULL AND date(datetime_open) >= $1)
                        UNION ALL
                        (SELECT COUNT(DISTINCT USER_ID) FROM PUBLIC.ANALISE_DRIVER
                        WHERE TO_DELETE IS NOT NULL AND date(datetime_open) >= $1) 
        """
        return await self.pool.fetch(sql, date)

